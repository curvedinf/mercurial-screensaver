<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mercurial</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
    </style>
</head>
<body>
    <canvas id="gl-canvas"></canvas>
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 a_position;
        varying vec2 v_texCoord;
        void main() {
            gl_Position = vec4(a_position, 0.0, 1.0);
            v_texCoord = a_position * 0.5 + 0.5;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">
        precision highp float;
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform sampler2D u_prevFrame; 
        varying vec2 v_texCoord;
        #define PI 3.14159265359
        #define NUM_SAMPLES 12
        #define SHAPE_RADIUS 0.55
        #define ROT_Y_SPEED 0.1
        #define ROT_X_SPEED -0.1
        #define HUE_SPEED 0.04
        #define SATURATION_SPEED 0.3
        #define SATURATION_BASE 0.98
        #define VALUE_SPEED 0.5
        #define VALUE_BASE 0.6
        #define GRADIENT_LENGTH 20.0
        #define BLUR_RADIUS 40.0
        #define MELT_ROT_SPEED 0.3
        #define DECAY_SPEED 0.999
        #define DECAY_FIXED 0.003
        #define MAX_MELT_UP vec2(-4.5, -12.9)
        #define MAX_MELT_LEFT vec2(12.9, 4.5)
        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }
        mat3 rotateY(float angle) {
            float s = sin(angle);
            float c = cos(angle);
            return mat3(c, 0.0, -s, 0.0, 1.0, 0.0, s, 0.0, c);
        }
        mat3 rotateX(float angle) {
            float s = sin(angle);
            float c = cos(angle);
            return mat3(1.0, 0.0, 0.0, 0.0, c, s, 0.0, -s, c);
        }
        vec2 map(vec3 p) {
            mat3 rotation = rotateY(u_time * ROT_Y_SPEED) * rotateX(u_time * ROT_X_SPEED);
            p *= rotation;
            const float phi = 1.61803398875;
            vec3 n = normalize(vec3(0.0, 1.0, phi));
            
            vec3 q = abs(p); 
            float d1 = dot(q, n);
            float d2 = dot(q, n.zxy);
            float d3 = dot(q, n.yzx);
            
            float dist = max(max(d1, d2), d3) - SHAPE_RADIUS; 
            float a = max(d1, max(d2, d3)); 
            float b = min(d1, min(d2, d3)); 
            float c = (d1 + d2 + d3) - a - b; 
            float edge = a - c; 
            return vec2(dist, edge);
        }
        void main() {
            float sin_wave = (sin(u_time * MELT_ROT_SPEED) + 1.0) * 0.5;
            vec2 melt_direction = normalize(mix(MAX_MELT_UP, MAX_MELT_LEFT, sin_wave));
            
            vec2 melt_coord_offset = melt_direction / u_resolution;
            vec2 melt_center_coord = v_texCoord + melt_coord_offset;
            
            vec4 blurred_color = vec4(0.0);
            
            for (int i = 0; i < NUM_SAMPLES; i++) {
                float angle = float(i) / float(NUM_SAMPLES) * 2.0 * PI;
                vec2 sample_offset = vec2(cos(angle), sin(angle)) * BLUR_RADIUS / u_resolution;
                blurred_color += texture2D(u_prevFrame, melt_center_coord + sample_offset);
            }
            
            blurred_color /= float(NUM_SAMPLES);
            vec4 prevFrameColor = blurred_color * DECAY_SPEED - DECAY_FIXED;
            vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / u_resolution.y;
            
            vec3 ro = vec3(0.0, 0.0, 2.0); 
            vec3 rd = normalize(vec3(uv, -6.0)); 
            float t = 0.0;
            float shapeMask = 0.0;
            const int MAX_STEPS = 64;
            const float MAX_DIST = 100.0;
            const float HIT_DIST = 0.001;

            vec3 hitPos = vec3(0.0);

            for (int i = 0; i < MAX_STEPS; i++) {
                vec3 pos = ro + t * rd;
                vec2 res = map(pos);
                float dist = res.x;
                float edge = res.y;
                if (dist < HIT_DIST) {
                    shapeMask = 1.0 - smoothstep(0.0, 0.025, edge);
                    hitPos = pos;
                    break;
                }
                t += dist;
                if (t > MAX_DIST) {
                    break;
                }
            }

            float hue;
            float time_for_hue = u_time;
            if (shapeMask > 0.0) {
                mat3 rotation = rotateY(u_time * ROT_Y_SPEED) * rotateX(u_time * ROT_X_SPEED);
                vec3 localPos = hitPos * rotation;
                float time_offset = dot(localPos, normalize(vec3(1.0, 1.0, 1.0))) * GRADIENT_LENGTH;
                time_for_hue += time_offset;
            }
            hue = fract(time_for_hue * HUE_SPEED);

            float saturation = cos(u_time * SATURATION_SPEED) * (1.0 - SATURATION_BASE) + SATURATION_BASE;
            float value = sin(u_time * VALUE_SPEED) * (1.0 - VALUE_BASE) + VALUE_BASE;
            vec3 shapeColor = hsv2rgb(vec3(hue, saturation, value));
            vec4 newColor = vec4(shapeColor, 1.0) * shapeMask;
            gl_FragColor = prevFrameColor + newColor;
        }
    </script>
    <script>
        'use strict';
        function main() {
            const canvas = document.getElementById('gl-canvas');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL is not supported by your browser.');
                return;
            }
            const vsSource = document.getElementById('vertex-shader').textContent;
            const fsSource = document.getElementById('fragment-shader').textContent;
            const program = createProgram(gl, vsSource, fsSource);
            const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
            const resolutionUniformLocation = gl.getUniformLocation(program, 'u_resolution');
            const timeUniformLocation = gl.getUniformLocation(program, 'u_time');
            const prevFrameUniformLocation = gl.getUniformLocation(program, 'u_prevFrame');
            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            const positions = [-1, -1, 3, -1, -1, 3]; 
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
            let fbo1 = createFramebuffer(gl, gl.canvas.width, gl.canvas.height);
            let fbo2 = createFramebuffer(gl, gl.canvas.width, gl.canvas.height);
            let readFBO = fbo1;
            let writeFBO = fbo2;
            let then = 0;
            function render(now) {
                now *= 0.001; 
                const deltaTime = now - then;
                then = now;
                resizeCanvasToDisplaySize(gl.canvas);
                const width = gl.canvas.width;
                const height = gl.canvas.height;
                if (width !== readFBO.width || height !== readFBO.height) {
                    fbo1 = createFramebuffer(gl, width, height);
                    fbo2 = createFramebuffer(gl, width, height);
                    readFBO = fbo1;
                    writeFBO = fbo2;
                }
                gl.useProgram(program);
                gl.enableVertexAttribArray(positionAttributeLocation);
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
                
                gl.uniform2f(resolutionUniformLocation, gl.canvas.width, gl.canvas.height);
                gl.uniform1f(timeUniformLocation, now);
                
                gl.uniform1i(prevFrameUniformLocation, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, readFBO.texture);
                gl.bindFramebuffer(gl.FRAMEBUFFER, writeFBO.framebuffer);
                gl.viewport(0, 0, width, height);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.bindTexture(gl.TEXTURE_2D, writeFBO.texture);
                gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                [readFBO, writeFBO] = [writeFBO, readFBO];
                requestAnimationFrame(render);
            }
            requestAnimationFrame(render);
        }
        function createProgram(gl, vsSource, fsSource) {
            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vsSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }
        
        function createFramebuffer(gl, width, height) {
            const framebuffer = gl.createFramebuffer();
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            const texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            return { framebuffer, texture, width, height };
        }
        function resizeCanvasToDisplaySize(canvas) {
            const displayWidth  = canvas.clientWidth;
            const displayHeight = canvas.clientHeight;
            if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
                canvas.width = displayWidth;
                canvas.height = displayHeight;
                return true;
            }
            return false;
        }
        window.onload = main;
    </script>
</body>
</html>
